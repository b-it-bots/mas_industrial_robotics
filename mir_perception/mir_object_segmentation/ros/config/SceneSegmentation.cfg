#! /usr/bin/env python

PACKAGE='mir_object_segmentation'

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

pc_object_segmentation = gen.add_group("Pointcloud object segmentation")
# def add (self, name, paramtype, level, description, default = None, min = None, max = None, edit_method = ""):
pc_object_segmentation.add ("octree_resolution", double_t, 0, "Octree resolution", 0.0025, 0, 2.0)
pc_os_voxel = pc_object_segmentation.add_group("Voxel filter")
pc_os_voxel.add ("voxel_leaf_size", double_t, 0, "The size of a leaf (on x,y,z) used for downsampling.", 0.009, 0, 1.0)
pc_os_voxel.add ("voxel_filter_field_name", str_t, 0, "The field name used for filtering", "z")
pc_os_voxel.add ("voxel_filter_limit_min", double_t, 0, "The minimum allowed field value a point will be considered from", -0.15, -10.0, 10.0)
pc_os_voxel.add ("voxel_filter_limit_max", double_t, 0, "The maximum allowed field value a point will be considered from", 0.25, -10.0, 10.0)

pc_os_passthrough = pc_object_segmentation.add_group("Passthrough filter")
pc_os_passthrough.add ("enable_passthrough_filter", bool_t, 0, "Enable passthrough filter", False)
pc_os_passthrough.add ("passthrough_filter_field_name", str_t, 0, "The field name used for filtering", "x")
pc_os_passthrough.add ("passthrough_filter_limit_min", double_t, 0, "The minimum allowed field value a point will be considered from", 0.0, -10.0, 10.0)
pc_os_passthrough.add ("passthrough_filter_limit_max", double_t, 0, "The maximum allowed field value a point will be considered from", 0.8, -10.0, 10.0)

pc_os_cropbox = pc_object_segmentation.add_group("Cropbox filter")
pc_os_cropbox.add ("enable_cropbox_filter", bool_t, 0, "Enable cropbox filter", False)
pc_os_cropbox.add ("cropbox_filter_min_x", double_t, 0, "The minimum allowed x value a point will be considered from", 0.0, -10.0, 10.0)
pc_os_cropbox.add ("cropbox_filter_max_x", double_t, 0, "The maximum allowed x value a point will be considered from", 0.8, -10.0, 10.0)
pc_os_cropbox.add ("cropbox_filter_min_y", double_t, 0, "The minimum allowed y value a point will be considered from", -0.5, -10.0, 10.0)
pc_os_cropbox.add ("cropbox_filter_max_y", double_t, 0, "The maximum allowed y value a point will be considered from", 0.8, -10.0, 10.0)
pc_os_cropbox.add ("cropbox_filter_min_z", double_t, 0, "The minimum allowed z value a point will be considered from", -0.2, -10.0, 10.0)
pc_os_cropbox.add ("cropbox_filter_max_z", double_t, 0, "The maximum allowed z value a point will be considered from", 0.6, -10.0, 10.0)


pc_os_sac = pc_object_segmentation.add_group("SAC segmentation")
pc_os_sac.add ("normal_radius_search", double_t,  0, "Sphere radius for nearest neighbor search",  0.03, 0.0, 0.5)
pc_os_sac.add ("use_omp", bool_t,  0, "Use Open MP to estimate normal",  False)
pc_os_sac.add ("num_cores", int_t,  0, "The number of cores to use for OMP normal estimation",  4, 1, 16)
pc_os_sac.add ("sac_max_iterations", int_t, 0, "The maximum number of iterations the algorithm will run for", 1000, 0, 100000)
pc_os_sac.add ("sac_distance_threshold", double_t, 0, "The distance to model threshold", 0.01, 0, 1.0)
pc_os_sac.add ("sac_optimize_coefficients", bool_t, 0, "Model coefficient refinement", True)
pc_os_sac.add ("sac_x_axis", double_t, 0, "The x axis to which the plane should be perpendicular, the eps angle > 0 to activate axis-angle constraint", 0.0, 0.0, 1.0)
pc_os_sac.add ("sac_y_axis", double_t, 0, "The y axis to which the plane should be perpendicular, the eps angle > 0 to activate axis-angle constraint", 0.0, 0.0, 1.0)
pc_os_sac.add ("sac_z_axis", double_t, 0, "The z axis to which the plane should be perpendicular, the eps angle > 0 to activate axis-angle constraint", 1.0, 0.0, 1.0)
pc_os_sac.add ("sac_eps_angle", double_t, 0, "The maximum allowed difference between the model normal and the given axis in radians.", 0.09, 0.0, 1.5707)
pc_os_sac.add ("sac_normal_distance_weight", double_t, 0, "The relative weight (between 0 and 1) to give to the angular distance (0 to pi/2) between point normals and the plane normal.", 0.05, 0, 1.0)
pc_os_sac.add ("prism_min_height", double_t, 0, "The minimum height above the plane from which to construct the polygonal prism", 0.01, 0.0, 5.0)
pc_os_sac.add ("prism_max_height", double_t, 0, "The maximum height above the plane from which to construct the polygonal prism", 0.1, 0.0, 5.0)
pc_os_sac.add ("outlier_radius_search", double_t, 0, "Radius of the sphere that will determine which points are neighbors.", 0.03, 0.0, 10.0)
pc_os_sac.add ("outlier_min_neighbors", int_t, 0, "The number of neighbors that need to be present in order to be classified as an inlier.", 20, 0, 1000)

pc_os_cluster = pc_object_segmentation.add_group("Object cluster")
pc_os_cluster.add ("cluster_tolerance", double_t, 0, "The spatial tolerance as a measure in the L2 Euclidean space", 0.02, 0.0, 2.0)
pc_os_cluster.add ("cluster_min_size", int_t, 0, "The minimum number of points that a cluster must contain in order to be accepted", 25, 0, 1000)
pc_os_cluster.add ("cluster_max_size", int_t, 0, "The maximum number of points that a cluster must contain in order to be accepted", 20000, 0, 2147483647)
pc_os_cluster.add ("cluster_min_height", double_t, 0, "The minimum height of the cluster above the given polygon", 0.011, 0, 5.0)
pc_os_cluster.add ("cluster_max_height", double_t, 0, "The maximum height of the cluster above the given polygon", 0.09, 0, 5.0)
pc_os_cluster.add ("cluster_max_length", double_t, 0, "The maximum length of the cluster", 0.25, 0, 5.0)
pc_os_cluster.add ("cluster_min_distance_to_polygon", double_t, 0, "The minimum height of the cluster above the given polygon", 0.04, 0, 5.0)
pc_os_cluster.add ("center_cluster", bool_t,  0, "Center cluster",  True)
pc_os_cluster.add ("pad_cluster", bool_t,  0, "Pad cluster so that it has the same size",  False)
pc_os_cluster.add ("padded_cluster_size", int_t, 0, "The size of the padded cluster", 2048, 128, 4096)

object_pose = gen.add_group("Object pose")
object_pose.add ("object_height_above_workspace", double_t, 0, "The height of the object above the workspace", 0.052, 0, 2.0)

exit (gen.generate (PACKAGE, "mir_object_segmentation", "SceneSegmentation"))

