#!/usr/bin/env python
from __future__ import print_function

import numpy as np
import rospy
import yaml
import os

from sensor_msgs.msg import Image
from std_msgs.msg import String

import cv2 as cv
from cv_bridge import CvBridge, CvBridgeError

class GraspVerifier(object):
    def __init__(self):
        self._process_method_dict = {
                "thr": self._process_img_thr,
                "hsv": self._process_img_hsv
                }
        # ros parameters
        self._debug = rospy.get_param("~debug", False)
        template_img_path = rospy.get_param("~template_img_path", None)
        self._process_method = rospy.get_param("~process_method", "thr") # can be "thr" or "hsv"
        config_file_path = rospy.get_param("~config_file_path", None)
        template_images_dir = rospy.get_param("~template_images_dir", None)

        if template_images_dir is None:
            rospy.logfatal("template_images_dir is empty")
            rospy.signal_shutdown("template_images_dir is empty")
            return
        if not os.path.exists(template_images_dir):
            rospy.logfatal("template_images_dir: " + template_images_dir + " does not exist")
            rospy.signal_shutdown("template_images_dir: " + template_images_dir + " does not exist")
            return

        if config_file_path is None:
            rospy.logfatal("config_file_path is empty")
            rospy.signal_shutdown("config_file_path is empty")
            return
        if not os.path.exists(config_file_path):
            rospy.logfatal("config_file_path: " + config_file_path + " does not exist")
            rospy.signal_shutdown("config_file_path: " + config_file_path + " does not exist")
            return

        # class variables
        self._bridge = CvBridge()
        self._listening = False
        self._crop_bbox = [440, 100, 170, 280] # x, y, width, height
        self._bg_polygon = np.array([ [0, 0], [40, 0], [5, 90], [10, 200],
                                      [42, self._crop_bbox[3]],
                                      [0, self._crop_bbox[3]] ])
        self._bordersize = 20 # px
        # for thresholding based method
        self._adaptive_threshold_ksize = 17
        self._adaptive_threshold_c = 2
        self._median_blur_ksize = 5
        # for HSV based method
        self._hmin = 0
        self._hmax = 60
        self._smin = 50
        self._smax = 255
        self._vmin = 30
        self._vmax = 255

        config_read_success = self._read_config_file(config_file_path, template_images_dir)
        if not config_read_success:
            rospy.logfatal("config_file_path: " + config_file_path + " not as expected.")
            rospy.signal_shutdown("config_file_path: " + config_file_path + " not as expected")
            return

        # publishers
        self._event_out_pub = rospy.Publisher("~event_out", String, queue_size=1)
        self._debug_image_pub = rospy.Publisher("~debug_image", Image, queue_size=1)

        # subscribers
        self._event_in_sub = rospy.Subscriber("~event_in", String, self._event_in_cb)
        self._image_sub = rospy.Subscriber("~input_rgb_image", Image, self._input_image_cb)

        rospy.loginfo("Initialised GraspVerifier")

    def _read_config_file(self, config_file_path, template_images_dir):
        with open(config_file_path, "r") as file_obj:
            data = yaml.safe_load(file_obj)
        if not isinstance(data, dict):
            rospy.logerr("Expected dict object while reading config file")
            return False
        if "template_matching_params" not in data:
            rospy.logerr("template_matching_params not found in config file")
            return False
        tm_params = data["template_matching_params"]
        if not isinstance(tm_params, list):
            rospy.logerr("Expected template_matching_params to be of list type")
            return False
        total_weight = 0.0
        for i, tm_param in enumerate(tm_params):
            if "img_name" not in tm_param\
                    or "process_method" not in tm_param\
                    or "weight" not in tm_param:
                rospy.logerr("Expected img_name, process_method and weight"\
                             + " for each template_matching_params item")
                return False
            template_img_path = os.path.join(template_images_dir, tm_param["img_name"])
            if not os.path.exists(template_img_path):
                rospy.logerr("template_img_path: " + template_img_path + " does not exist")
                return False
            template_img_raw = cv.imread(template_img_path)
            process_method = tm_param["process_method"]
            if process_method not in self._process_method_dict:
                rospy.logerr("Unknown process_method " + process_method)
                return False
            template_img = self._process_method_dict[process_method](template_img_raw)
            tm_param["template_img"] = template_img
            weight = tm_param["weight"]
            if not isinstance(weight, float):
                rospy.logerr("Expected float value for weight, got " + str(type(weight)))
                return False
            total_weight += weight

        if total_weight != 1.0:
            rospy.logerr("Total weight for template images does not add up to 1")
            return False

        self._tm_params = tm_params
        return True

    def _event_in_cb(self, msg):
        if msg.data == "e_start":
            self._listening = True
            self._event_out_pub.publish(String(data="e_started"))
        if msg.data == "e_stop":
            self._listening = False
            self._event_out_pub.publish(String(data="e_stopped"))
        if msg.data == "e_trigger":
            self._listening = True

    def _input_image_cb(self, msg):
        """
        Callback for image from camera. 

        :msg: sensor_msgs.Image
        :returns: None

        """
        if not self._listening:
            return

        try:
            cv_image = self._bridge.imgmsg_to_cv2(msg, "bgr8")
        except CvBridgeError as e:
            rospy.logerr("Could not convert ros sensor msgs Image to opencv Image.")
            rospy.logerr(str(e))
            self._check_failure()
            return

        total_score = 0.0
        for tm_param in self._tm_params:
            process_method = tm_param["process_method"]
            # process the input image based on `process_method`
            processed_test_img = self._process_method_dict[process_method](cv_image)
            # add border around for "robust" matching
            processed_test_border_img = cv.copyMakeBorder(
                processed_test_img,
                top=self._bordersize,
                bottom=self._bordersize,
                left=self._bordersize,
                right=self._bordersize,
                borderType=cv.BORDER_CONSTANT,
                value=0)
            # if process_method == "hsv":
            #     self._pub_debug_img(processed_test_img, encoding="passthrough")

            # match test img with template_img
            score_img = cv.matchTemplate(processed_test_border_img,
                    tm_param["template_img"], cv.TM_CCOEFF_NORMED)
            _, max_value, _, _ = cv.minMaxLoc(score_img);
            score = round(max_value*100, 2)
            total_score += score * tm_param["weight"]
            print(process_method, "Matched:", score, "%")
            # self._pub_debug_img(score_img, encoding="passthrough")
        print("Total score:", total_score)
        print()

    def _pub_debug_img(self, img, encoding="bgr8"):
        if self._debug:
            try:
                ros_debug_img = self._bridge.cv2_to_imgmsg(img, encoding=encoding)
                self._debug_image_pub.publish(ros_debug_img)
            except CvBridgeError as e:
                rospy.logwarn("Could not convert debug cv image to ros image")
                pass

    def _process_img_thr(self, raw_img):
        bw_raw_img = cv.cvtColor(raw_img, cv.COLOR_BGR2GRAY)
        cropped_img = bw_raw_img[self._crop_bbox[1]:self._crop_bbox[1]+self._crop_bbox[3],
                                 self._crop_bbox[0]:self._crop_bbox[0]+self._crop_bbox[2]]

        # thresholding
        adaptive_thr_img = cv.adaptiveThreshold(
                cropped_img,
                255,
                cv.ADAPTIVE_THRESH_GAUSSIAN_C,
                cv.THRESH_BINARY_INV,
                self._adaptive_threshold_ksize,
                self._adaptive_threshold_c)

        # add black polygon to remove background
        polygon_img = adaptive_thr_img.copy()
        cv.fillPoly(polygon_img, pts =[self._bg_polygon], color=(0,0,0))

        # Blur image
        blur_median_img = cv.medianBlur(polygon_img, self._median_blur_ksize)
        return blur_median_img

    def _process_img_hsv(self, raw_img):
        cropped_img = raw_img[self._crop_bbox[1]:self._crop_bbox[1]+self._crop_bbox[3],
                              self._crop_bbox[0]:self._crop_bbox[0]+self._crop_bbox[2]]

        # normalise image (src: https://stackoverflow.com/a/66676709/10460994)
        img_yuv = cv.cvtColor(cropped_img, cv.COLOR_BGR2YCrCb)
        img_yuv[:,:,0] = cv.equalizeHist(img_yuv[:,:,0])
        eq_hist_img = cv.cvtColor(img_yuv, cv.COLOR_YCrCb2BGR)

        # apply hsv filter
        hsv_raw_img = cv.cvtColor(eq_hist_img, cv.COLOR_BGR2HSV)
        lower = np.array([self._hmin, self._smin, self._vmin], np.uint8)
        upper = np.array([self._hmax, self._smax, self._vmax], np.uint8)
        masked_img = cv.inRange(cropped_img, lower, upper)
        return masked_img

if __name__ == "__main__":
    rospy.init_node("grasp_verifier")
    GV = GraspVerifier()
    rospy.spin()
    print("Exiting.")
