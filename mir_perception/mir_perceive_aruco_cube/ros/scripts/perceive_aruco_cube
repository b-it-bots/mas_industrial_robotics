#!/usr/bin/env python
from __future__ import print_function

import rospy
import cv2
import pcl
import math
import tf
import numpy as np
from tf2_ros import Buffer, TransformListener
from tf2_sensor_msgs.tf2_sensor_msgs import do_transform_cloud
from sensor_msgs.msg import Image, PointCloud2
from geometry_msgs.msg import Point, PointStamped, Polygon, PolygonStamped, Quaternion, PoseStamped
import sensor_msgs.point_cloud2 as pc2
from cv_bridge import CvBridge, CvBridgeError
from message_filters import ApproximateTimeSynchronizer, Subscriber

class ArucoCubePerceiver(object):

    def __init__(self):
        self.bridge = CvBridge()
        self.aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_4X4_50)
        self.target_frame = rospy.get_param('~target_frame', 'base_link')
        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer)
        self.tf_br = tf.TransformBroadcaster()
        self.debug_polygon_pub = rospy.Publisher('/polygon_debug_topic', PolygonStamped, queue_size=1)
        self.output_pose_pub = rospy.Publisher('~output_pose', PoseStamped, queue_size=1)
        self.image_sub = Subscriber("~input_rgb_image", Image)
        self.pc_sub = Subscriber("~input_pointcloud", PointCloud2)
        self.ats = ApproximateTimeSynchronizer([self.image_sub, self.pc_sub], queue_size = 5, slop=0.000001)
        self.ats.registerCallback(self.synchronized_msg_cb)
        self.listening = True

    def synchronized_msg_cb(self, img_msg, pc_msg):
        if not self.listening:
            return
        try:
            cv_image = self.bridge.imgmsg_to_cv2(img_msg, "bgr8")
        except CvBridgeError as e:
            print(e)
            return

        corners = self._get_best_aruco_marker_corners(cv_image)
        if corners is None:
            return
        rospy.loginfo("Aruco corners in image frame\n" + str(corners))

        trans = None
        try:
            trans = self.tf_buffer.lookup_transform(self.target_frame,
                                                    pc_msg.header.frame_id,
                                                    pc_msg.header.stamp,
                                                    rospy.Duration(5.0))
        except Exception as e:
            rospy.logerr(str(e))
        if trans is None:
            rospy.logerr("Could not find a transform.")
            return
        transformed_pc = do_transform_cloud(pc_msg, trans)
        height, width = pc_msg.height, pc_msg.width
        pc = self.ros_to_pcl(transformed_pc)
        polygon = Polygon()
        for corner in corners:
            point_vector = ArucoCubePerceiver.get_point_at(pc, corner[1], corner[0], height, width)
            polygon.points.append(Point(x=point_vector[0], y=point_vector[1], z=point_vector[2]))

        cube_center = self.get_cube_center_from_side_polygon(polygon, trans)

        # for visualisation
        polygon_stamped = PolygonStamped(polygon=polygon)
        polygon_stamped.header.stamp = rospy.Time.now()
        polygon_stamped.header.frame_id = self.target_frame
        self.debug_polygon_pub.publish(polygon_stamped)

        p1 = np.array([polygon.points[0].x, polygon.points[0].y, polygon.points[0].z])
        p2 = np.array([polygon.points[1].x, polygon.points[1].y, polygon.points[1].z])
        vec = p2 - p1
        roll = math.atan2(vec[2], vec[1])
        pitch = math.atan2(vec[2], vec[0])
        yaw = math.atan2(vec[1], vec[0])
        print(roll, pitch, yaw)

        pose = PoseStamped()
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = self.target_frame
        pose.pose.position = cube_center
        pose.pose.orientation = Quaternion(*tf.transformations.quaternion_from_euler(roll, pitch, yaw))
        self.output_pose_pub.publish(pose)

        self.listening = False

    def get_cube_center_from_side_polygon(self, polygon, trans):
        """Calculate the center of the cube from a polygon representing one side
        of that cube

        1. Find the normal to plane formed by the 3 out of the 4 given points
	2. Find the center of the square by calculating the average of all 4 points
	3. Find any point on the line passing through the center and parallel to
	   normal to the plane with equation `new_point = center + some_factor*normal`
	4. Find the side of the square by finding distance between any 2 adjacent
	   points on the square and lets call it `d`
	5. Find the length of the normal vector and lets call it `l`
	6. Find value of `some_factor` with equation `d / (l * 2)`
	7. Find both the points with equation from 3
	8. Find the point furthest from camera frame


        :polygon: geometry_msgs/Polygon
        :trans: geometry_msgs/Transformation
        :returns: geometry_msgs/Point

        """
        # center of square
        sq_center = Point(x=sum([point.x for point in polygon.points])/len(polygon.points),
                          y=sum([point.y for point in polygon.points])/len(polygon.points),
                          z=sum([point.z for point in polygon.points])/len(polygon.points))

        side_length = ArucoCubePerceiver.calculate_dist(polygon.points[0], polygon.points[1])

        # find normal vector of the plane formed by the polygon
        np_corners = []
        for point in polygon.points:
            np_corners.append(np.array([point.x, point.y, point.z]))
        a, b, c = np.cross(np_corners[-1] - np_corners[0], np_corners[1] - np_corners[0])

        # find optimal factor to be mul with normal vector such that the point is
        # side_length/2 meters away from sq_center
        normal_length = (a**2 + b**2 + c**2)**0.5
        lamda = side_length / (normal_length * 2)
        possible_cube_center = [Point(x=sq_center.x + lamda*a, y=sq_center.y + lamda*b, z=sq_center.z + lamda*c),
                                Point(x=sq_center.x - lamda*a, y=sq_center.y - lamda*b, z=sq_center.z - lamda*c)]

        # get the point furthest from camera (assumption: pointcloud was received in camera frame)
        camera_point = Point(x=trans.transform.translation.x,
                             y=trans.transform.translation.y,
                             z=trans.transform.translation.z)
        distances = [ArucoCubePerceiver.calculate_dist(camera_point, p) for p in possible_cube_center]
        cube_center_index = distances.index(max(distances))
        cube_center = possible_cube_center[cube_center_index]
        return cube_center

    @staticmethod
    def calculate_dist(p1, p2):
        """Calculate the distance between 2 points
        :p1: geometry_msgs/Point
        :p2: geometry_msgs/Point
        :returns: float

        """
        return ((p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2)**0.5

    @staticmethod
    def get_point_at(pc, row, col, height, width):
        ind = row*width + col
        if ind > width*height:
            return None
        return pc[ind][:3]

    def ros_to_pcl(self, pc_msg):
        points_list = []

        for data in pc2.read_points(pc_msg, skip_nans=False):
            points_list.append([data[0], data[1], data[2], data[3]])

        pcl_data = pcl.PointCloud_PointXYZRGB()
        pcl_data.from_list(points_list)

        return pcl_data 

    def _get_best_aruco_marker_corners(self, img):
        corners_set, ids, rejectedImgPoints = cv2.aruco.detectMarkers(img, self.aruco_dict)
        if ids is None:
            return None
        variances = [np.var((np.squeeze(corner_set))) for corner_set in corners_set]
        max_variance_index = variances.index(max(variances))
        best_corners = np.squeeze(corners_set[max_variance_index])
        return best_corners


if __name__ == '__main__':
    rospy.init_node('image_converter')
    ACP = ArucoCubePerceiver()
    rospy.spin()
    # cv2.destroyAllWindows()
    print("Exiting.")
