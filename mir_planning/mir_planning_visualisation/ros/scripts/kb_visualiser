#!/usr/bin/env python

from __future__ import print_function

import tf
import os
import math
import rospy
from visualization_msgs.msg import MarkerArray, Marker
from geometry_msgs.msg import Quaternion
from rosplan_knowledge_msgs.srv import GetAttributeService
from rosplan_knowledge_msgs.msg import KnowledgeItem

class KnowledgeBaseVisualiser(object):

    """
    TODO
    """

    def __init__(self):
        # read ros params
        self._debug = rospy.get_param('~debug', False)
        self._global_frame = rospy.get_param('~global_frame', 'map')
        self._alpha = rospy.get_param('~alpha', 1.0)
        base_link_to_ws_edge = rospy.get_param('~base_link_to_ws_edge', 0.4)
        self._kb_server_topic = rospy.get_param('~kb_server_topic', None)
        if self._kb_server_topic is None:
            raise Exception('Topic for querying knowledge base not provided.')
        self._model_path = rospy.get_param('~model_path', None)
        if self._model_path is None:
            raise Exception('Model path not provided.')
        if not os.path.exists(self._model_path):
            raise Exception('Invalid model path provided. ' + str(self._model_path) + ' does not exist')
        self._marker_config = rospy.get_param('~model_to_marker_config', None)
        if self._marker_config is None:
            raise Exception('Model config not provided.')
        navigation_goals = rospy.get_param('~navigation_goals', None)
        if navigation_goals is None:
            raise Exception('Navigation goal file not provided.')

        # Subscribers

        # Publishers
        self._kb_marker_pub = rospy.Publisher('~markers', MarkerArray, queue_size=1)

        # Action servers

        # class variables
        self._marker_counter = 1
        self._ws_pos = dict()
        # offset nav goal based on size of robot to initialise workstation poses
        for ws, pos in navigation_goals.iteritems():
            delta_x = (math.cos(pos[2]) * base_link_to_ws_edge)
            delta_y = (math.sin(pos[2]) * base_link_to_ws_edge)
            self._ws_pos[ws.lower()] = [pos[0] + delta_x, pos[1] + delta_y, pos[2]]

        rospy.loginfo('Initialised')

    def test(self):
        rospy.sleep(1.0)
        resp = self._get_response_from_kb()
        if resp is None or (isinstance(resp, list) and len(resp) == 0):
            rospy.loginfo('No valid response')
            return
        else:
            obj_on_ws = {}
            for fact in resp:
                if fact[0] == 'on':
                    if fact[1]['l'] in obj_on_ws:
                        obj_on_ws[fact[1]['l']].append(fact[1]['o'])
                    else:
                        obj_on_ws[fact[1]['l']] = [fact[1]['o']]

        msg = MarkerArray()
        markers = self._get_markers_from_ws_pos()
        msg.markers = markers
        # obj_on_ws = {'ws01':['M20', 'M30', 'axis', 'm20_100', 'f20_20_g', 'f20_20_b'],
        #              'ws02':['s40_40_g', 's40_40_b', 'bearing', 'bearing_box', 'distance_tube'],
        #              'sh01':['M20', 'M30', 'axis', 'm20_100', 'f20_20_g', 'f20_20_b'],
        #              'cb01':['M20', 'M30', 'axis', 'm20_100', 'f20_20_g', 'f20_20_b']}
        for ws_name, obj_list in obj_on_ws.iteritems():
            obj_markers = self._get_markers_from_obj_on_ws(obj_list, ws_name)
            msg.markers.extend(obj_markers)
        self._kb_marker_pub.publish(msg)
        rospy.loginfo('Published')
        rospy.sleep(3)

    def _get_response_from_kb(self):
        rospy.loginfo('Waiting for service: ' + self._kb_server_topic)
        rospy.wait_for_service(self._kb_server_topic)
        rospy.loginfo('Service ' + self._kb_server_topic + ' is available, proceeding')
        try:
            pending_goals = rospy.ServiceProxy(self._kb_server_topic, GetAttributeService)
            response = pending_goals()
            if len(response.attributes) == 0:
                rospy.logwarn('No propositions in KB')
                return None
            else:
                rospy.loginfo('Found propositions: ' + str(len(response.attributes)))
                facts = [attribute for attribute in response.attributes 
                         if attribute.knowledge_type == KnowledgeItem.FACT]
                resp = [(fact.attribute_name, {kv.key:kv.value for kv in fact.values}) for fact in facts]
                return resp
                # for fact in resp:
                #     if fact.attribute_name == 'on':
                #         dict_obj = {kv.key:kv.value for kv in fact.values}
                #         print(dict_obj)
        except rospy.ServiceException, e:
            rospy.logerr('Service call failed: %s'%e)
            return None

    def _get_markers_from_ws_pos(self):
        """Create markers for workstations
        :returns: list of visualization_msgs.Marker

        """
        markers = []
        for ws, pos in self._ws_pos.iteritems():
            if 'ws' in ws:
                marker = self._get_marker_from_obj_name_and_pos('ws', x=pos[0], y=pos[1], yaw=pos[2])
            elif 'sh' in ws:
                marker = self._get_marker_from_obj_name_and_pos('sh', x=pos[0], y=pos[1], yaw=pos[2])
            elif 'pp' in ws:
                marker = self._get_marker_from_obj_name_and_pos('pp', x=pos[0], y=pos[1], yaw=pos[2])
            elif 'cb' in ws:
                marker = self._get_marker_from_obj_name_and_pos('cb', x=pos[0], y=pos[1], yaw=pos[2])
                config = self._marker_config['cb']
                marker.type = Marker.CYLINDER
                marker.scale.x = marker.scale.y = config['scale']
                marker.scale.z = 0.02
            else:
                continue
            markers.append(marker)
        return markers

    def _get_markers_from_obj_on_ws(self, obj_list, ws_name):
        ws = ws_name.lower()
        pos = self._ws_pos.get(ws, None)
        if pos is None:
            return []
        markers = []
        if 'ws' in ws or 'sh' in ws:
            obj_pose_offsets = [(x, y) for x in [0.05, 0.2] for y in [0.0, 0.15, 0.3, -0.15, -0.3]]
        elif 'cb' in ws:
            cb_radius = self._marker_config['cb']['scale']/2.0
            obj_pose_offsets = [(math.cos(math.radians(theta))*cb_radius*0.8 + cb_radius,
                                 math.sin(math.radians(theta))*cb_radius*0.8)
                                for theta in range(0, 360, 36)]
        else:
            return []

        if len(obj_list) > 10:
            rospy.logwarn('Only showing 10 objects on ' + str(ws))
        for obj, offset in zip(obj_list, obj_pose_offsets):
            delta_x = (math.cos(pos[2]) * offset[0]) + (-math.sin(pos[2]) * offset[1])
            delta_y = (math.sin(pos[2]) * offset[0]) + (math.cos(pos[2]) * offset[1])
            marker = self._get_marker_from_obj_name_and_pos(
                    obj, x=pos[0]+delta_x, y=pos[1]+delta_y, z=0.1, yaw=pos[2])
            markers.append(marker)
        return markers

    def _get_marker_from_obj_name_and_pos(self, obj_name, x=0.0, y=0.0, z=0.0,
                                          yaw=0.0, frame=None):
        if frame is None:
            frame = self._global_frame

        # TODO: make obj name into correct format (e.g. axis-00 -> axis)
        obj_name = obj_name.lower()
        marker = Marker()
        if obj_name not in self._marker_config:
            rospy.logwarn('Could not find ' + str(obj_name) + '. Using default marker')
            marker.type = Marker.CUBE
            config = self._marker_config['default']
        else:
            config = self._marker_config[obj_name]
            file_path = os.path.join(self._model_path, config['file_name'])
            if os.path.exists(file_path):
                resource_file = 'file://' + file_path
                marker.type=Marker.MESH_RESOURCE
                marker.mesh_resource = resource_file
            else:
                rospy.logwarn('Could not find file ' + str(file_path) + '. Using default marker')
                marker.type = Marker.CUBE
                config = self._marker_config['default']

        marker.header.stamp = rospy.Time.now()
        marker.scale.x = marker.scale.y = marker.scale.z = config['scale']
        marker.color.r = config['color']['r']
        marker.color.g = config['color']['g']
        marker.color.b = config['color']['b']
        marker.color.a = self._alpha
        angle = math.radians(config['offset']['yaw']) + yaw
        quat = tf.transformations.quaternion_from_euler(
                math.radians(config['offset']['roll']),
                math.radians(config['offset']['pitch']),
                angle)
        marker.pose.orientation = Quaternion(*quat)
        delta_x = (math.cos(angle) * config['offset']['x']) \
                + (-math.sin(angle) * config['offset']['y'])
        delta_y = (math.sin(angle) * config['offset']['x']) \
                + (math.cos(angle) * config['offset']['y'])
        marker.pose.position.x = x + delta_x
        marker.pose.position.y = y + delta_y
        marker.pose.position.z = z + config['offset']['z']
        marker.header.frame_id = frame
        marker.id = self._marker_counter
        self._marker_counter += 1
        return marker


if __name__ == '__main__':
    rospy.init_node('planning_visualiser')
    visualiser = KnowledgeBaseVisualiser()
    visualiser.test()
