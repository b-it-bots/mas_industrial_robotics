#!/usr/bin/env python

from __future__ import print_function

import tf
import os
import math
import yaml
import rospy
from visualization_msgs.msg import MarkerArray, Marker
from geometry_msgs.msg import Quaternion
from rosplan_knowledge_msgs.srv import GetAttributeService
from rosplan_knowledge_msgs.msg import KnowledgeItem

class KnowledgeBaseVisualiser(object):

    """
    TODO
    """

    def __init__(self):
        # read ros params
        self._debug = rospy.get_param('~debug', False)
        self._global_frame = rospy.get_param('~global_frame', 'map')
        self._alpha = rospy.get_param('~alpha', 1.0)
        self._base_link_to_ws_edge = rospy.get_param('~base_link_to_ws_edge', 0.4)
        self._kb_server_topic = '~kb_server_topic'

        self._model_path = rospy.get_param('~model_path', None)
        if self._model_path is None:
            raise Exception('Model path not provided.')
        if not os.path.exists(self._model_path):
            raise Exception('Invalid model path provided. ' + str(self._model_path) + ' does not exist')

        marker_config_file = rospy.get_param('~model_to_marker_config', None)
        self._marker_config = None
        with open(marker_config_file) as file_obj:
            self._marker_config = yaml.safe_load(file_obj)
        if self._marker_config is None:
            raise Exception('Model config not provided.')

        navigation_goals = rospy.get_param('~navigation_goals', None)
        if navigation_goals is None:
            raise Exception('Navigation goal file not provided.')

        # Subscribers

        # Publishers
        self._kb_marker_pub = rospy.Publisher('~markers', MarkerArray, queue_size=1)

        # Action servers

        # class variables
        self._marker_counter = 0
        self._ws_pos = dict()
        # offset nav goal based on size of robot to initialise workstation poses
        for ws, pos in navigation_goals.iteritems():
            delta_x = (math.cos(pos[2]) * self._base_link_to_ws_edge)
            delta_y = (math.sin(pos[2]) * self._base_link_to_ws_edge)
            self._ws_pos[ws.lower()] = [pos[0] + delta_x, pos[1] + delta_y, pos[2]]

        rospy.sleep(1.0)
        self._kb_marker_pub.publish(MarkerArray(markers=[Marker(action=Marker.DELETEALL)]))
        rospy.loginfo('Initialised')

    def visualise(self):
        self._kb_marker_pub.publish(MarkerArray(markers=[Marker(action=Marker.DELETEALL)]))
        self._marker_counter = 0
        resp = self._get_response_from_kb()
        if resp is None or (isinstance(resp, list) and len(resp) == 0):
            rospy.loginfo('No valid response')
            return
        obj_on_ws = {}
        robot_ws = 'start'
        obj_on_robot = {}
        for fact in resp:
            if self._debug:
                print(fact)
            if fact[0] == 'on':
                if fact[1]['l'] in obj_on_ws:
                    obj_on_ws[fact[1]['l']].append(fact[1]['o'])
                else:
                    obj_on_ws[fact[1]['l']] = [fact[1]['o']]
            if fact[0] == 'stored':
                obj_on_robot[fact[1]['rp']] = fact[1]['o']
            if fact[0] == 'at':
                robot_ws = fact[1]['l']

        msg = MarkerArray()
        markers = self._get_markers_from_ws_pos()
        msg.markers.extend(markers)
        for ws_name, obj_list in obj_on_ws.iteritems():
            obj_markers = self._get_markers_from_obj_on_ws(obj_list, ws_name)
            msg.markers.extend(obj_markers)
        msg.markers.extend(self._get_markers_for_youbot(robot_ws))
        msg.markers.extend(self._get_markers_from_obj_on_robot(obj_on_robot, robot_ws))
        self._kb_marker_pub.publish(msg)

    def _get_response_from_kb(self):
        if self._debug:
            rospy.loginfo('Waiting for service: ' + self._kb_server_topic)
        rospy.wait_for_service(self._kb_server_topic)
        try:
            pending_goals = rospy.ServiceProxy(self._kb_server_topic, GetAttributeService)
            response = pending_goals()
            if len(response.attributes) == 0:
                rospy.logwarn('No propositions in KB')
                return None
            else:
                if self._debug:
                    rospy.loginfo('Found propositions: ' + str(len(response.attributes)))
                facts = [attribute for attribute in response.attributes 
                         if attribute.knowledge_type == KnowledgeItem.FACT]
                resp = [(fact.attribute_name, {kv.key:kv.value for kv in fact.values})
                        for fact in facts]
                return resp
        except rospy.ServiceException, e:
            rospy.logerr('Service call failed: %s'%e)
            return None

    def _get_markers_from_ws_pos(self):
        """Create markers for workstations

        :returns: list of visualization_msgs.Marker

        """
        markers = []
        for ws, pos in self._ws_pos.iteritems():
            if 'ws' in ws:
                marker = self._get_marker_from_obj_name_and_pos('ws', x=pos[0], y=pos[1], yaw=pos[2])
            elif 'sh' in ws:
                marker = self._get_marker_from_obj_name_and_pos('sh', x=pos[0], y=pos[1], yaw=pos[2])
            elif 'pp' in ws:
                marker = self._get_marker_from_obj_name_and_pos('pp', x=pos[0], y=pos[1], yaw=pos[2])
            elif 'cb' in ws:
                marker = self._get_marker_from_obj_name_and_pos('cb', x=pos[0], y=pos[1], yaw=pos[2])
                config = self._marker_config['cb']
                marker.type = Marker.CYLINDER
                marker.scale.x = marker.scale.y = config['scale']
                marker.scale.z = 0.02
            else:
                continue
            markers.append(marker)
        return markers

    def _get_markers_for_youbot(self, robot_ws='start'):
        """Create markers for robot

        :ws_name: str
        :returns: list of visualization_msgs.Marker

        """
        x, y, yaw = self._ws_pos.get(robot_ws.lower(), [0.0, 0.0, 0.0])
        delta_x = (math.cos(yaw) * self._base_link_to_ws_edge)
        delta_y = (math.sin(yaw) * self._base_link_to_ws_edge)
        x, y = x-delta_x, y-delta_y
        keys = ['youbot', 'arm_0', 'arm_1', 'arm_2', 'arm_3', 'arm_4', 'arm_5',\
                'arm_palm', 'youbot_plate', 'yb_wheel_lf', 'yb_wheel_rf',\
                'yb_wheel_lb', 'yb_wheel_rb']
        marker_dict = {key:self._get_marker_from_obj_name_and_pos(key, x=x, y=y, z=0.05, yaw=yaw)
                       for key in keys}
        for key, marker in marker_dict.iteritems():
            if 'wheel' in key:
                marker.type = Marker.SPHERE
        return marker_dict.values()

    def _get_markers_from_obj_on_ws(self, obj_list, ws_name):
        ws = ws_name.lower()
        pos = self._ws_pos.get(ws, None)
        if pos is None:
            return []
        markers = []
        if 'ws' in ws or 'sh' in ws:
            obj_pose_offsets = [(x, y) for x in [0.05, 0.2] for y in [0.0, 0.15, -0.15, 0.3, -0.3]]
        elif 'cb' in ws:
            cb_radius = self._marker_config['cb']['scale']/2.0
            obj_pose_offsets = [(math.cos(math.radians(theta))*cb_radius*0.8 + cb_radius,
                                 math.sin(math.radians(theta))*cb_radius*0.8)
                                for theta in range(0, 360, 36)]
        else:
            return []

        if len(obj_list) > 10:
            rospy.logwarn('Only showing 10 objects on ' + str(ws))
        for obj, offset in zip(obj_list, obj_pose_offsets):
            delta_x = (math.cos(pos[2]) * offset[0]) + (-math.sin(pos[2]) * offset[1])
            delta_y = (math.sin(pos[2]) * offset[0]) + (math.cos(pos[2]) * offset[1])
            marker = self._get_marker_from_obj_name_and_pos(
                    obj, x=pos[0]+delta_x, y=pos[1]+delta_y, z=0.1, yaw=pos[2])
            markers.append(marker)
        return markers

    def _get_markers_from_obj_on_robot(self, obj_on_robot, robot_ws):
        x, y, yaw = self._ws_pos.get(robot_ws.lower(), [0.0, 0.0, 0.0])
        delta_x = (math.cos(yaw) * self._base_link_to_ws_edge)
        delta_y = (math.sin(yaw) * self._base_link_to_ws_edge)
        x, y = x-delta_x, y-delta_y
        markers = []
        obj_pose_offsets = {platform:(-0.1, y) for platform, y in zip(
                                ['platform_middle', 'platform_left', 'platform_right'],
                                [0.0, 0.1, -0.1])}

        for platform, obj in obj_on_robot.iteritems():
            offset = obj_pose_offsets.get(platform.lower(), None)
            if offset is None:
                rospy.logwarn('Object ' + obj + ' on unknown platform '+ platform)
                continue
            delta_x = (math.cos(yaw) * offset[0]) + (-math.sin(yaw) * offset[1])
            delta_y = (math.sin(yaw) * offset[0]) + (math.cos(yaw) * offset[1])
            marker = self._get_marker_from_obj_name_and_pos(
                    obj, x=x+delta_x, y=y+delta_y, z=0.11, yaw=yaw)
            markers.append(marker)
        return markers

    def _get_marker_from_obj_name_and_pos(self, obj_name, x=0.0, y=0.0, z=0.0,
                                          yaw=0.0, frame=None):
        if frame is None:
            frame = self._global_frame

        obj_name = obj_name.split('-')[0] if '-' in obj_name else obj_name
        obj_name = obj_name.lower()
        marker = Marker()
        if obj_name not in self._marker_config:
            rospy.logwarn('Could not find ' + str(obj_name) + '. Using default marker')
            marker.type = Marker.CUBE
            config = self._marker_config['default']
        else:
            config = self._marker_config[obj_name]
            file_path = os.path.join(self._model_path, config['file_name'])
            if os.path.exists(file_path):
                resource_file = 'file://' + file_path
                marker.type=Marker.MESH_RESOURCE
                marker.mesh_resource = resource_file
            else:
                rospy.logwarn('Could not find file ' + str(file_path) + '. Using default marker')
                marker.type = Marker.CUBE
                config = self._marker_config['default']

        marker.header.stamp = rospy.Time.now()
        marker.scale.x = marker.scale.y = marker.scale.z = config['scale']
        marker.color.r = config['color']['r']
        marker.color.g = config['color']['g']
        marker.color.b = config['color']['b']
        marker.color.a = self._alpha
        # marker.color.r = marker.color.g = marker.color.b = marker.color.a = 0.0
        # marker.mesh_use_embedded_materials = True
        angle = math.radians(config['offset']['yaw']) + yaw
        quat = tf.transformations.quaternion_from_euler(
                math.radians(config['offset']['roll']),
                math.radians(config['offset']['pitch']),
                angle)
        marker.pose.orientation = Quaternion(*quat)
        delta_x = (math.cos(angle) * config['offset']['x']) \
                + (-math.sin(angle) * config['offset']['y'])
        delta_y = (math.sin(angle) * config['offset']['x']) \
                + (math.cos(angle) * config['offset']['y'])
        marker.pose.position.x = x + delta_x
        marker.pose.position.y = y + delta_y
        marker.pose.position.z = z + config['offset']['z']
        marker.header.frame_id = frame
        self._marker_counter += 1
        marker.id = self._marker_counter
        return marker

if __name__ == '__main__':
    rospy.init_node('kb_visualiser')
    VISUALISER = KnowledgeBaseVisualiser()
    RATE = rospy.Rate(rospy.get_param('~rate', 0.2))
    while not rospy.is_shutdown():
        VISUALISER.visualise()
        RATE.sleep()
    rospy.loginfo('Exiting...')
