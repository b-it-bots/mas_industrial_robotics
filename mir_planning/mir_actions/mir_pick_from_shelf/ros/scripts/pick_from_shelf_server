#!/usr/bin/python

from __future__ import print_function

import sys
import copy

import mcr_states.common.basic_states as gbs
import mir_states.common.manipulation_states as gms
import rospy
import smach
from geometry_msgs.msg import PoseStamped, Quaternion, TwistStamped
from mir_actions.utils import Utils
from mir_planning_msgs.msg import (
    GenericExecuteAction,
    GenericExecuteFeedback,
    GenericExecuteResult,
)
from smach_ros import ActionServerWrapper, IntrospectionServer
from std_msgs.msg import String
from tf.transformations import quaternion_from_euler, euler_from_quaternion
import tf
from pick_from_shelf_utils import PickFromShelfUtils
import math
   
# ===============================================================================
class SelectObject(smach.State):
    def __init__(self, topic_name):
        smach.State.__init__(
            self,
            outcomes=["succeeded"],
            input_keys=["goal"],
            output_keys=["feedback", "result"],
        )
        self.publisher = rospy.Publisher(topic_name, String, queue_size=10)
        rospy.sleep(0.1)  # time for the publisher to register in ros network

    def execute(self, userdata):
        # Add empty result msg (because if none of the state do it, action server gives error)
        userdata.result = GenericExecuteResult()
        userdata.feedback = GenericExecuteFeedback(
            current_state="SelectObject", text="selecting object"
        )

        obj = Utils.get_value_of(userdata.goal.parameters, "object")
        self.publisher.publish(String(data=obj))
        rospy.sleep(0.2)  # let the topic to survive for some time
        return "succeeded"

# ===============================================================================

class SendPoseToDBC(smach.State):
    def __init__(self, retract=False, adjust_pose=False):
        smach.State.__init__(self, outcomes=["succeeded"])
        self._dbc_pose_pub = rospy.Publisher(
            "/mcr_navigation/direct_base_controller/input_pose",
            PoseStamped,
            queue_size=10,
        )
        _obj_pose_sub = rospy.Subscriber(
            "mcr_perception/object_selector/output/object_pose",
            PoseStamped,
            self._obj_pose_cb,
        )
        self._obj_pose_pub = rospy.Publisher(
            "mcr_perception/object_selector/output/object_pose",
            PoseStamped,
            queue_size=10,
        )
        self._obj_pose = None
        self.retract = retract
        self.adjust_pose = adjust_pose
        self.listener = tf.TransformListener()
        self.utils = PickFromShelfUtils()
        rospy.sleep(0.1)  # time for the publisher to register in ros network

    def _obj_pose_cb(self, msg):
        self._obj_pose = copy.deepcopy(msg)
        self._new_obj_pose = copy.deepcopy(msg)

    def angle_diff(self, angle1, angle2):
        return abs(math.atan2(math.sin(angle1-angle2), math.cos(angle1-angle2)))

    def execute(self, userdata):
        if self.retract:
            # get tf of base_link 
            tf_msg = self.listener.lookupTransform("/base_link_static", "/base_link", rospy.Time(0))
            # get the pose of the object in base_link frame
            pose_msg = PoseStamped()
            pose_msg.header.frame_id = "base_link_static"
            pose_msg.header.stamp = rospy.Time.now()
            # amount to move backward after pick object
            pose_msg.pose.position.x = tf_msg[0][0] - 0.175
            pose_msg.pose.position.y = tf_msg[0][1]
            pose_msg.pose.position.z = tf_msg[0][2]
            pose_msg.pose.orientation.x = tf_msg[1][0]
            pose_msg.pose.orientation.y = tf_msg[1][1]
            pose_msg.pose.orientation.z = tf_msg[1][2]
            pose_msg.pose.orientation.w = tf_msg[1][3]
            dbc_pose = pose_msg
            #dbc_pose = self.utils.get_retracted_dbc_pose()
        elif self.adjust_pose:
            self._obj_pose.pose.position.y -= 0.1
            self._obj_pose.pose.position.x += 0.05
            dbc_pose = self.utils.calc_pose_for_dbc(self._obj_pose)
            
            self._new_obj_pose.pose.position.x -= 0.1
            # modify the orientation of the object pose
            pose_rpy = euler_from_quaternion(
                [
                    self._new_obj_pose.pose.orientation.x,
                    self._new_obj_pose.pose.orientation.y,
                    self._new_obj_pose.pose.orientation.z,
                    self._new_obj_pose.pose.orientation.w,
                ]
            )
            # if angle diff is less than 45 
            if self.angle_diff(pose_rpy[2], math.pi/2) < 0.785:
                # set the orientation to 90
                self._new_obj_pose.pose.orientation = Quaternion(*quaternion_from_euler(0, 0, 1.5708))
            elif self.angle_diff(pose_rpy[2], -math.pi/2) < 0.785:
                # set the orientation to -90
                self._new_obj_pose.pose.orientation = Quaternion(*quaternion_from_euler(0, 0, -1.5708))
            self._obj_pose_pub.publish(self._new_obj_pose)
        else:
            # print(f'obj pose: {self._obj_pose}')
            # get tf of base_link 
            tf_msg = self.listener.lookupTransform("/base_link_static", "/base_link", rospy.Time(0))
            # get the pose of the object in base_link frame
            pose_msg = PoseStamped()
            pose_msg.header.frame_id = "base_link_static"
            pose_msg.header.stamp = rospy.Time.now()
            # amount to move forward to pick object
            pose_msg.pose.position.x = tf_msg[0][0] + 0.127
            pose_msg.pose.position.y = tf_msg[0][1]
            pose_msg.pose.position.z = tf_msg[0][2]
            pose_msg.pose.orientation.x = tf_msg[1][0]
            pose_msg.pose.orientation.y = tf_msg[1][1]
            pose_msg.pose.orientation.z = tf_msg[1][2]
            pose_msg.pose.orientation.w = tf_msg[1][3]
            dbc_pose = pose_msg
            # dbc_pose = self.utils.calc_pose_for_dbc(pose_msg)
        self._dbc_pose_pub.publish(dbc_pose)
        self._obj_pose = None
        return "succeeded"

# ===============================================================================

class SendPoseToMoveIt(smach.State):
    def __init__(self, modification_name="intermediate"):
        smach.State.__init__(self, outcomes=["succeeded"])
        self._moveit_pose_pub = rospy.Publisher(
            "/arm_moveit_client/target_pose", PoseStamped, queue_size=10
        )
        _obj_pose_sub = rospy.Subscriber(
            "mcr_perception/object_selector/output/object_pose",
            PoseStamped,
            self._obj_pose_cb,
        )
        self._obj_pose = None
        self._modification_name = modification_name
        self.utils = PickFromShelfUtils()
        rospy.sleep(0.1)  # time for the publisher to register in ros network

    def _obj_pose_cb(self, msg):
        self._obj_pose = copy.deepcopy(msg)

    def execute(self, userdata):
        modified_obj_pose = self.utils.get_arm_pose(
            self._obj_pose, self._modification_name
        )
        rospy.loginfo("Modified pose")
        rospy.loginfo(modified_obj_pose)
        self._moveit_pose_pub.publish(modified_obj_pose)
        self._obj_pose = None
        return "succeeded"

# ===============================================================================

class MoveArmUp(smach.State):
    def __init__(self):
        smach.State.__init__(
            self,
            outcomes=["succeeded"],
            input_keys=["goal"],
            output_keys=["feedback", "result"],
        )
        # velocity publisher
        self.arm_velocity_pub = rospy.Publisher("/arm_1/arm_controller/cartesian_velocity_command", TwistStamped, queue_size=10)
    
    def execute(self, userdata):
        
        # send the velocity in +z direction wrt base_link to move the arm up
        vel_msg = TwistStamped()
        vel_msg.header.frame_id = "base_link"
        # set velocity to 5cm/s
        vel_msg.twist.linear.z = 0.05
        self.arm_velocity_pub.publish(vel_msg)
        rospy.sleep(0.5) 
        # stop the arm
        vel_msg.twist.linear.z = 0
        self.arm_velocity_pub.publish(vel_msg)
        return "succeeded"

# ===============================================================================

def main():
    # Open the container
    rospy.init_node("pick_from_shelf_server")
    # Construct state machine
    sm = smach.StateMachine(
        outcomes=["OVERALL_SUCCESS", "OVERALL_FAILED"],
        input_keys=["goal"],
        output_keys=["feedback", "result"],
    )

    with sm:
        smach.StateMachine.add(
            "SELECT_OBJECT",
            SelectObject("/mcr_perception/object_selector/input/object_name"),
            transitions={"succeeded": "GENERATE_OBJECT_POSE"},
        )

        # generates a pose of object
        smach.StateMachine.add(
            "GENERATE_OBJECT_POSE",
            gbs.send_and_wait_events_combined(
                event_in_list=[
                    ("/mcr_perception/object_selector/event_in", "e_trigger")
                ],
                event_out_list=[
                    ("/mcr_perception/object_selector/event_out", "e_selected", True,)
                ],
                timeout_duration=10,
            ),
            transitions={
                "success": "SET_DBC_PARAMS",
                "timeout": "OVERALL_FAILED",
                "failure": "OVERALL_FAILED",
            },
        )

        smach.StateMachine.add(
            "SET_DBC_PARAMS",
            gbs.set_named_config("dbc_pick_object"),
            transitions={
                "success": "SEND_DBC_POSE",
                "timeout": "OVERALL_FAILED",
                "failure": "OVERALL_FAILED",
            },
        )

        smach.StateMachine.add(
            "SEND_DBC_POSE",
            SendPoseToDBC(retract=False, adjust_pose=True),
            transitions={"succeeded": "MOVE_BASE_USING_DBC"},
        )

        # Move base using direct base controller
        smach.StateMachine.add(
            "MOVE_BASE_USING_DBC",
            gbs.send_and_wait_events_combined(
                event_in_list=[
                    (
                        "/mcr_navigation/direct_base_controller/coordinator/event_in",
                        "e_start",
                    )
                ],
                event_out_list=[
                    (
                        "/mcr_navigation/direct_base_controller/coordinator/event_out",
                        "e_success",
                        True,
                    )
                ],
                timeout_duration=10,
            ),
            transitions={
                "success": "OPEN_GRIPPER",
                "timeout": "OVERALL_FAILED",
                "failure": "OVERALL_FAILED",
            },
        )

        smach.StateMachine.add(
            "OPEN_GRIPPER",
            gms.control_gripper(-1.4), #range -1.5 to 1, -1.5 is wide open, 0 is open, 1 is closed
            transitions={"succeeded": "MOVE_ROBOT_AND_PICK",
                         "timeout": "MOVE_ROBOT_AND_PICK"},
        )

        smach.StateMachine.add(
            "MOVE_ARM_TO_PRE_GRASP",
            gms.move_arm("shelf_pre_grasp_lower"),
            transitions={
                "succeeded": "MOVE_ROBOT_AND_PICK",
                "failed": "MOVE_ARM_TO_PRE_GRASP",
            },
        )

        smach.StateMachine.add(
            "MOVE_ROBOT_AND_PICK",
            gbs.send_and_wait_events_combined(
                event_in_list=[("/wbc/event_in", "e_start")],
                event_out_list=[("/wbc/event_out", "e_success", True)],
                timeout_duration=50,
            ),
            transitions={
                "success": "MOVE_FRONT_TO_PICK",
                "timeout": "MOVE_ARM_TO_PRE_PLACE",
                "failure": "MOVE_ARM_TO_PRE_PLACE",
            },
        )

        # move front to pick
        smach.StateMachine.add(
            "MOVE_FRONT_TO_PICK",
            SendPoseToDBC(retract=False),
            transitions={"succeeded": "MOVE_BASE_FRONT_USING_DBC"},
        )

        # Move base using direct base controller
        smach.StateMachine.add(
            "MOVE_BASE_FRONT_USING_DBC",
            gbs.send_and_wait_events_combined(
                event_in_list=[
                    (
                        "/mcr_navigation/direct_base_controller/coordinator/event_in",
                        "e_start",
                    )
                ],
                event_out_list=[
                    (
                        "/mcr_navigation/direct_base_controller/coordinator/event_out",
                        "e_success",
                        True,
                    )
                ],
                timeout_duration=10,
            ),
            transitions={
                "success": "CLOSE_GRIPPER",
                "timeout": "OVERALL_FAILED",
                "failure": "OVERALL_FAILED",
            },
        )

        smach.StateMachine.add(
            "CLOSE_GRIPPER",
            gms.control_gripper("close"),
            transitions={"succeeded": "VERIFY_OBJECT_GRASPED",
                         "timeout": "VERIFY_OBJECT_GRASPED"},
        )

        smach.StateMachine.add(
            "VERIFY_OBJECT_GRASPED",
            gms.verify_object_grasped(3),
            transitions={
                "succeeded": "MOVE_ARM_UP",
                "timeout": "MOVE_ARM_UP",
                "failed": "SEND_DBC_POSE_RETRACT",
            },
        )

        # move arm up
        smach.StateMachine.add(
            "MOVE_ARM_UP",
            MoveArmUp(),
            transitions={
                "succeeded": "SEND_DBC_POSE_RETRACT"
            },
        )

        smach.StateMachine.add(
            "SEND_DBC_POSE_RETRACT",
            SendPoseToDBC(retract=True),
            transitions={"succeeded": "MOVE_BASE_USING_DBC_RETRACT"},
        )

        # Move base using direct base controller
        smach.StateMachine.add(
            "MOVE_BASE_USING_DBC_RETRACT",
            gbs.send_and_wait_events_combined(
                event_in_list=[
                    (
                        "/mcr_navigation/direct_base_controller/coordinator/event_in",
                        "e_start",
                    )
                ],
                event_out_list=[
                    (
                        "/mcr_navigation/direct_base_controller/coordinator/event_out",
                        "e_success",
                        True,
                    )
                ],
                timeout_duration=10,
            ),
            transitions={
                "success": "MOVE_ARM_TO_PRE_PLACE",
                "timeout": "MOVE_ARM_TO_PRE_PLACE",
                "failure": "MOVE_ARM_TO_PRE_PLACE",
            },
        )

        smach.StateMachine.add(
            "MOVE_ARM_TO_PRE_PLACE", # next action will be staging the object not placing it the pose name is pre-place commonly used everywhere
            gms.move_arm("pre_place"),
            transitions={
                "succeeded": "OVERALL_SUCCESS",
                "failed": "MOVE_ARM_TO_PRE_PLACE",
            },
        )

    # smach viewer
    if rospy.get_param("~viewer_enabled", True):
        sis = IntrospectionServer(
            "pick_from_shelf_viewer", sm, "/PICK_FROM_SHELF_SMACH_VIEWER"
        )
        sis.start()

    # Construct action server wrapper
    asw = ActionServerWrapper(
        server_name="pick_from_shelf_server",
        action_spec=GenericExecuteAction,
        wrapped_container=sm,
        succeeded_outcomes=["OVERALL_SUCCESS"],
        aborted_outcomes=["OVERALL_FAILED"],
        preempted_outcomes=["PREEMPTED"],
        goal_key="goal",
        feedback_key="feedback",
        result_key="result",
    )
    # Run the server in a background thread
    asw.run_server()
    rospy.spin()


if __name__ == "__main__":
    main()
